import type { CAC } from "cac";
import pc from "picocolors";
import path from "path";
import fs from "fs/promises";
import { banner } from "../utils/common";
import { select } from "@clack/prompts";

declare const Bun: typeof import("bun");

type BuildOptions = {
	path: string;
	outdir: string;
	minify: boolean;
};

function toPosixPath(p: string): string {
	return p.split(path.sep).join("/");
}

function ensureRelImport(p: string): string {
	return p.startsWith(".") ? p : `./${p}`;
}

function routeFromFile(baseDir: string, absFile: string): string | null {
	const rel = path.relative(baseDir, absFile);
	const relNoExt = rel.replace(/\.ts$/i, "");
	const parts = relNoExt.split(path.sep).filter(Boolean);
	if (parts.length === 0) return null;
	if (parts[parts.length - 1] === "index") parts.pop();
	if (parts.length === 0) return null;
	return parts.join(".");
}

async function listTsFilesRecursive(dir: string): Promise<string[]> {
	try {
		await fs.access(dir);
	} catch {
		return [];
	}

	const out: string[] = [];
	const entries = await fs.readdir(dir, { withFileTypes: true });
	for (const e of entries) {
		const full = path.join(dir, e.name);
		if (e.isDirectory()) {
			out.push(...(await listTsFilesRecursive(full)));
		} else if (
			e.isFile() &&
			e.name.endsWith(".ts") &&
			!e.name.endsWith(".d.ts")
		) {
			out.push(full);
		}
	}
	return out;
}

function makeVar(
	prefix: "cmd" | "btn" | "ctx" | "sel" | "evt",
	route: string,
): string {
	const safe = route.replace(/[^a-zA-Z0-9_]+/g, "_");
	return `${prefix}_${safe}`;
}

function buildGeneratedEntry(opts: {
	genDir: string;
	commandsDir: string;
	buttonsDir: string;
	contextsDir: string;
	selectsDir: string;
	commandFiles: string[];
	buttonFiles: string[];
	contextFiles: string[];
	selectFiles: string[];
	eventFiles: string[];
}): string {
	const {
		genDir,
		commandsDir,
		buttonsDir,
		contextsDir,
		selectsDir,
		commandFiles,
		buttonFiles,
		contextFiles,
		selectFiles,
		eventFiles,
	} = opts;

	const imports: string[] = [];
	const commandRoutes: Array<{ route: string; varName: string }> = [];
	const buttonRoutes: Array<{ route: string; varName: string }> = [];
	const contextRoutes: Array<{ route: string; varName: string }> = [];
	const selectRoutes: Array<{ route: string; varName: string }> = [];
	const eventRoutes: Array<{ id: string; varName: string }> = [];

	for (const f of commandFiles) {
		const route = routeFromFile(commandsDir, f);
		if (!route) continue;
		const varName = makeVar("cmd", route);
		const rel = ensureRelImport(toPosixPath(path.relative(genDir, f)));
		imports.push(`import ${varName} from "${rel}";`);
		commandRoutes.push({ route, varName });
	}

	for (const f of buttonFiles) {
		const route = routeFromFile(buttonsDir, f);
		if (!route) continue;
		const varName = makeVar("btn", route);
		const rel = ensureRelImport(toPosixPath(path.relative(genDir, f)));
		imports.push(`import ${varName} from "${rel}";`);
		buttonRoutes.push({ route, varName });
	}

	for (const f of contextFiles) {
		const route = routeFromFile(contextsDir, f);
		if (!route) continue;
		const varName = makeVar("ctx", route);
		const rel = ensureRelImport(toPosixPath(path.relative(genDir, f)));
		imports.push(`import ${varName} from "${rel}";`);
		contextRoutes.push({ route, varName });
	}

	for (const f of selectFiles) {
		const route = routeFromFile(selectsDir, f);
		if (!route) continue;
		const varName = makeVar("sel", route);
		const rel = ensureRelImport(toPosixPath(path.relative(genDir, f)));
		imports.push(`import ${varName} from "${rel}";`);
		selectRoutes.push({ route, varName });
	}

	for (const f of eventFiles) {
		const fileName = path.basename(f, ".ts");
		const varName = makeVar("evt", fileName);
		const rel = ensureRelImport(toPosixPath(path.relative(genDir, f)));
		imports.push(`import ${varName} from "${rel}";`);
		eventRoutes.push({ id: fileName, varName });
	}

	const sortedCmds = commandRoutes.sort((a, b) =>
		a.route.localeCompare(b.route),
	);
	const sortedBtns = buttonRoutes.sort((a, b) =>
		a.route.localeCompare(b.route),
	);
	const sortedCtxs = contextRoutes.sort((a, b) =>
		a.route.localeCompare(b.route),
	);
	const sortedSels = selectRoutes.sort((a, b) =>
		a.route.localeCompare(b.route),
	);
	const sortedEvts = eventRoutes.sort((a, b) => a.id.localeCompare(b.id));

	return `/* Auto-generated by djs-core. Do not edit manually. */
import config from "../djs.config.ts";
import { DjsClient, type Route } from "@djs-core/runtime";
import { Events } from "discord.js";

${imports.join("\n")}

function assertConfig(x: unknown): asserts x is { token: string; servers: string[] } {
  if (!x || typeof x !== "object") throw new Error("Invalid config: expected an object");
  const obj = x as any;
  if (typeof obj.token !== "string" || obj.token.length === 0) throw new Error("Invalid config: token is missing");
  if (!Array.isArray(obj.servers)) throw new Error("Invalid config: servers must be an array");
}

async function main() {
  assertConfig(config);

  const commands: Route[] = [
${sortedCmds.map((c) => `    { route: ${JSON.stringify(c.route)}, command: ${c.varName} },`).join("\n")}
  ];

  const buttons = [
${sortedBtns.map((b) => `    ${b.varName},`).join("\n")}
  ];

${sortedBtns.map((b) => `  ${b.varName}.setCustomId(${JSON.stringify(b.route)});`).join("\n")}

  const contextMenus = [
${sortedCtxs.map((c) => `    ${c.varName},`).join("\n")}
  ];

${sortedCtxs
	.map((c) => {
		const parts = c.route.split(".");
		const leaf = parts[parts.length - 1];
		return `  ${c.varName}.setName(${JSON.stringify(leaf)});`;
	})
	.join("\n")}

  const selectMenus = [
${sortedSels.map((s) => `    ${s.varName},`).join("\n")}
  ];

${sortedSels.map((s) => `  ${s.varName}.setCustomId(${JSON.stringify(s.route)});`).join("\n")}

  const events = {
${sortedEvts.map((e) => `    ${JSON.stringify(e.id)}: ${e.varName},`).join("\n")}
  };

  const client = new DjsClient({ servers: config.servers });

  client.eventsHandler.set(events);

  client.once(Events.ClientReady, async () => {
    client.commandsHandler.set(commands);
    client.contextMenusHandler.set(contextMenus);
    client.applicationCommandHandler.setCommands(commands);
    client.applicationCommandHandler.setContextMenus(
      client.contextMenusHandler.getContextMenus(),
    );
    await client.applicationCommandHandler.sync();
    client.buttonsHandler.set(buttons);
    client.selectMenusHandler.set(selectMenus);
    console.log(\`✅ Bot online (\${client.user?.tag ?? "unknown"})\`);
  });

  process.on("SIGINT", async () => {
    console.log("\\nShutting down...");
    await client.destroy();
    process.exit(0);
  });

  process.on("SIGTERM", async () => {
    console.log("\\nShutting down...");
    await client.destroy();
    process.exit(0);
  });

  await client.login(config.token);
}

main();
`;
}

export function registerBuildCommand(cli: CAC) {
	cli
		.command("build", "Build production bundle")
		.option("-p, --path <path>", "Custom project path", { default: "." })
		.option(
			"-o, --outdir <outdir>",
			"Output directory (relative to project root)",
			{ default: "dist" },
		)
		.option("--no-minify", "Disable minification")
		.action(async (options: BuildOptions) => {
			console.log(banner);

			const botRoot = path.resolve(process.cwd(), options.path);
			const genDir = path.join(botRoot, ".djscore");
			const entryPath = path.join(genDir, "index.ts");

			const commandsDir = path.join(botRoot, "interactions", "commands");
			const buttonsDir = path.join(botRoot, "interactions", "buttons");
			const contextsDir = path.join(botRoot, "interactions", "contexts");
			const selectsDir = path.join(botRoot, "interactions", "selects");
			const eventsDir = path.join(botRoot, "interactions", "events");

			console.log(`${pc.cyan("ℹ")}  Project: ${pc.bold(botRoot)}`);
			console.log(`${pc.cyan("ℹ")}  Generating: ${pc.bold(entryPath)}\n`);

			await fs.mkdir(genDir, { recursive: true });

			const commandFiles = await listTsFilesRecursive(commandsDir);
			const buttonFiles = await listTsFilesRecursive(buttonsDir);
			const contextFiles = await listTsFilesRecursive(contextsDir);
			const selectFiles = await listTsFilesRecursive(selectsDir);
			const eventFiles = await listTsFilesRecursive(eventsDir);

			const code = buildGeneratedEntry({
				genDir,
				commandsDir,
				buttonsDir,
				contextsDir,
				selectsDir,
				commandFiles,
				buttonFiles,
				contextFiles,
				selectFiles,
				eventFiles,
			});

			await fs.writeFile(entryPath, code, "utf8");

			const buildType = await select({
				message: "Select build type:",
				options: [
					{ value: "bun", label: "Bun (bundled)" },
					{ value: "bun-external", label: "Bun (external deps)" },
					{ value: "docker", label: "Docker" },
				],
			});

			if (typeof buildType !== "string") {
				console.log(pc.red("❌ Build cancelled"));
				process.exit(1);
			}

			const outdirAbs = path.resolve(botRoot, options.outdir);

			try {
				await fs.rm(outdirAbs, { recursive: true, force: true });
			} catch {
				// Ignore if directory doesn't exist
			}

			await fs.mkdir(outdirAbs, { recursive: true });

			const botPackageJsonPath = path.join(botRoot, "package.json");
			let externalDeps: string[] = [];

			if (buildType === "bun-external") {
				try {
					const botPackageJson = JSON.parse(
						await fs.readFile(botPackageJsonPath, "utf-8"),
					);
					externalDeps = [
						...Object.keys(botPackageJson.dependencies || {}),
						...Object.keys(botPackageJson.peerDependencies || {}),
						"discord.js",
					].filter((d) => d !== "@djs-core/runtime");
				} catch (_e) {
					console.warn(
						pc.yellow(
							"⚠️  Could not read package.json, using default externals",
						),
					);
					externalDeps = ["discord.js"];
				}
			}

			const result = await Bun.build({
				entrypoints: [entryPath],
				outdir: outdirAbs,
				target: "bun",
				minify: !!options.minify,
				splitting: false,
				sourcemap: "none",
				external: buildType === "bun-external" ? externalDeps : [],
			});

			if (!result.success) {
				console.error(pc.red("❌ Build failed"));
				for (const log of result.logs) console.error(log);
				process.exit(1);
			}

			const outputs = result.outputs.map((o: { path: string }) => o.path);
			const outputFile = path.join(outdirAbs, "index.js");
			const stats = await fs.stat(outputFile);
			const sizeKB = (stats.size / 1024).toFixed(2);
			const sizeMB = (stats.size / (1024 * 1024)).toFixed(2);
			const sizeDisplay =
				stats.size > 1024 * 1024 ? `${sizeMB} MB` : `${sizeKB} KB`;

			console.log(
				pc.green("✓") +
					`  Build success (${outputs.length} file${outputs.length === 1 ? "" : "s"}, ${sizeDisplay})`,
			);
			for (const p of outputs) console.log(pc.dim(`  - ${p}`));

			if (buildType === "docker") {
				const dockerfileContent = `FROM oven/bun:alpine
WORKDIR /app
COPY index.js .
CMD ["bun", "index.js"]
`;
				const dockerfilePath = path.join(outdirAbs, "Dockerfile");
				await fs.writeFile(dockerfilePath, dockerfileContent, "utf8");
				console.log(
					`${pc.green("✓")}  Dockerfile created: ${pc.bold("Dockerfile")}`,
				);
				console.log(
					pc.dim(
						`\nTip: build with: docker build -t my-bot ${options.outdir}\n`,
					),
				);
			} else if (buildType === "bun-external") {
				try {
					const botPackageJson = JSON.parse(
						await fs.readFile(botPackageJsonPath, "utf-8"),
					);
					const distPackageJson = {
						name: botPackageJson.name || "bot",
						version: botPackageJson.version || "1.0.0",
						type: "module",
						scripts: {
							start: "bun index.js",
						},
						dependencies: botPackageJson.dependencies || {},
						peerDependencies: botPackageJson.peerDependencies || {},
					};

					const distPackageJsonPath = path.join(outdirAbs, "package.json");
					await fs.writeFile(
						distPackageJsonPath,
						JSON.stringify(distPackageJson, null, 2),
						"utf8",
					);
					console.log(
						pc.green("✓") +
							`  package.json created: ${pc.bold("package.json")}`,
					);
					console.log(
						pc.dim(
							`\nTip: install deps then run: cd ${options.outdir} && bun install && bun start\n`,
						),
					);
				} catch (_e) {
					console.warn(pc.yellow("⚠️  Could not generate package.json"));
					console.log(
						pc.dim(
							`\nTip: run with: bun ${path.join(options.outdir, "index.js")}\n`,
						),
					);
				}
			} else {
				console.log(
					pc.dim(
						`\nTip: run with: bun ${path.join(options.outdir, "index.js")}\n`,
					),
				);
			}
		});
}
