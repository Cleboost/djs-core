/**
 * Copyright (c) 2025 Cleboost
 * External contributor can be found on the GitHub
 * Licence: on the GitHub
 */

import { build } from "tsup";
import { Config, DockerConfig } from "./config";
import { Readable } from "stream";
import fs from "fs";
import { BundlerReadable } from "./readable";
import { obfuscate } from "javascript-obfuscator";
import path from "path";

function generateDockerfile(config: DockerConfig, entryPoint: string = "index.js"): string {
  const baseImage = config.baseImage || "node:18-alpine";
  const port = config.port || 3000;
  const packages = config.packages || [];
  
  let dockerfile = `# Generated by @djs-core/builder
FROM ${baseImage}

WORKDIR /app

# Install additional packages if specified
`;

  if (packages.length > 0) {
    dockerfile += `RUN apk add --no-cache ${packages.join(" ")}\n\n`;
  }

  dockerfile += `# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy application code
COPY . .

# Create non-root user
RUN addgroup -g 1001 -S nodejs
RUN adduser -S botuser -u 1001
USER botuser

# Expose port
EXPOSE ${port}

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \\
  CMD node -e "console.log('Health check passed')" || exit 1

# Start the application
CMD ["node", "${entryPoint}"]
`;

  return dockerfile;
}

function generateDockerIgnore(): string {
  return `# Generated by @djs-core/builder
node_modules
npm-debug.log*
yarn-debug.log*
yarn-error.log*
.npm
.yarn-integrity

# Environment files
.env
.env.*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Coverage directory used by tools like istanbul
coverage
nyc_output

# Dependency directories
node_modules/
jspm_packages/

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Logs
logs
*.log

# Git
.git
.gitignore

# IDE
.vscode
.idea
*.swp
*.swo

# OS
.DS_Store
Thumbs.db

# Build artifacts
dist/
build/
*.tsbuildinfo

# Development
src/
*.ts
*.md
.editorconfig
.prettierrc
tsconfig.json
`;
}

function generateDockerCompose(config: DockerConfig): string {
  const port = config.port || 3000;
  const envVars = config.env || {};
  
  let compose = `# Generated by @djs-core/builder
version: '3.8'

services:
  discord-bot:
    build: .
    container_name: discord-bot
    restart: unless-stopped
    ports:
      - "${port}:${port}"
`;

  if (Object.keys(envVars).length > 0) {
    compose += `    environment:\n`;
    for (const [key, value] of Object.entries(envVars)) {
      compose += `      - ${key}=${value}\n`;
    }
  }

  compose += `    volumes:
      - ./logs:/app/logs:rw
    networks:
      - bot-network

networks:
  bot-network:
    driver: bridge
`;

  return compose;
}

function generatePackageJson(entryPoint: string = "index.js"): string {
  return `{
  "name": "discord-bot",
  "version": "1.0.0",
  "description": "Discord bot built with @djs-core/builder",
  "main": "${entryPoint}",
  "scripts": {
    "start": "node ${entryPoint}"
  },
  "dependencies": {
    "discord.js": "^14.0.0"
  },
  "engines": {
    "node": ">=18.0.0"
  }
}
`;
}

function bundleBot(config: Config): BundlerReadable {
  const stream = new Readable({
    read() {},
  }) as BundlerReadable;

  if (config.files.length === 0) {
    stream.emit("step", {
      id: "bundle",
      status: "error",
      message: "No files to bundle",
    });
    stream.push(null);
    return stream;
  }

  stream.emit("step", { id: "bundle", status: "start" });

  (async () => {
    try {
      await build({
        format: config.format || ["cjs"],
        outDir: config.dist || "dist",
        silent: config.log !== "debug",
        clean: config.clean ?? true,
        entry: config.files,
        minify: config.minify ?? false,
        dts: false,
        splitting: false,
        keepNames: true,
        treeshake: config.production ?? false,
      });
      stream.emit("step", { id: "bundle", status: "done" });
    } catch (error) {
      stream.emit("step", {
        id: "bundle",
        status: "error",
        message:
          error instanceof Error
            ? error.message
            : "Erreur inconnue lors du build",
      });
    }

    if (
      config.obfuscation ||
      (typeof config.obfuscation === "object" && config.production)
    ) {
      stream.emit("step", { id: "obfuscation", status: "start" });
      const index = fs.readFileSync(
        `${config.dist || "dist"}/index.js`,
        "utf-8",
      );
      const obfuscated = obfuscate(index, {
        target: "node",
        compact: true,
        controlFlowFlattening: true,
        stringArray: true,
        stringArrayThreshold: 1,
        stringArrayEncoding: ["rc4"],
        simplify: true,
      });
      fs.writeFileSync(
        `${config.dist || "dist"}/index.js`,
        obfuscated.getObfuscatedCode(),
      );
      if (config.log === "extend") {
        stream.emit("step", {
          id: "obfuscation",
          status: "progress",
          message: `${config.dist || "dist"}/index.js`,
        });
      }
      stream.emit("step", { id: "obfuscation", status: "done" });
    }

    if (config.artefact) {
      for (const art of config.artefact) {
        stream.emit("step", { id: "artefact", status: "start" });
        if (!fs.existsSync(art)) continue;
        fs.copyFileSync(
          art,
          `${config.dist || "dist"}/${art.replaceAll("src/", "")}`,
        );
        if (config.log === "extend") {
          stream.emit("step", {
            id: "artefact",
            status: "progress",
            message: `index.${art}`,
          });
        }
        stream.emit("step", { id: "artefact", status: "done" });
      }
    }

    if (config.docker) {
      stream.emit("step", { id: "docker", status: "start" });
      
      const dockerConfig: DockerConfig = typeof config.docker === "object" ? config.docker : {};
      const distDir = config.dist || "dist";
      
      try {
        // Determine the entry point by looking for the main bundled file
        let entryPoint = "index.js"; // default
        
        // Check if index.js exists (from CLI build)
        if (fs.existsSync(path.join(distDir, "index.js"))) {
          entryPoint = "index.js";
        } else {
          // Look for the first JS file in the dist directory
          const jsFiles = fs.readdirSync(distDir).filter(file => file.endsWith('.js'));
          if (jsFiles.length > 0) {
            entryPoint = jsFiles[0];
          }
        }
        
        // Generate Dockerfile
        const dockerfile = generateDockerfile(dockerConfig, entryPoint);
        fs.writeFileSync(path.join(distDir, "Dockerfile"), dockerfile);
        
        if (config.log === "extend") {
          stream.emit("step", {
            id: "docker",
            status: "progress",
            message: "Dockerfile created",
          });
        }

        // Generate .dockerignore
        const dockerignore = generateDockerIgnore();
        fs.writeFileSync(path.join(distDir, ".dockerignore"), dockerignore);
        
        if (config.log === "extend") {
          stream.emit("step", {
            id: "docker",
            status: "progress",
            message: ".dockerignore created",
          });
        }

        // Generate package.json if it doesn't exist
        const packageJsonPath = path.join(distDir, "package.json");
        if (!fs.existsSync(packageJsonPath)) {
          const packageJson = generatePackageJson(entryPoint);
          fs.writeFileSync(packageJsonPath, packageJson);
          
          if (config.log === "extend") {
            stream.emit("step", {
              id: "docker",
              status: "progress",
              message: "package.json created",
            });
          }
        }

        // Generate docker-compose.yml if enabled
        if (dockerConfig.compose !== false) {
          const dockerCompose = generateDockerCompose(dockerConfig);
          fs.writeFileSync(path.join(distDir, "docker-compose.yml"), dockerCompose);
          
          if (config.log === "extend") {
            stream.emit("step", {
              id: "docker",
              status: "progress",
              message: "docker-compose.yml created",
            });
          }
        }

        stream.emit("step", { id: "docker", status: "done" });
      } catch (error) {
        stream.emit("step", {
          id: "docker",
          status: "error",
          message: error instanceof Error ? error.message : "Unknown error during Docker generation",
        });
      }
    }

    stream.emit("end");
    stream.push(null);
  })();

  return stream;
}

export default bundleBot;
